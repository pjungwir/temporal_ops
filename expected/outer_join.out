-- Temporal outer join is equivalent to temporal inner join plus temporal antijoin.
-- But it feels like we should be able to do this in one pass of a instead of two.
SELECT  a.*, b.*,
        UNNEST(multirange(a.valid_at) * multirange(b.valid_at)) AS valid_at
FROM    a
JOIN    b
ON      a.id = b.id AND a.valid_at && b.valid_at
UNION ALL
SELECT  a.*, (NULL::b).*,
        UNNEST(
          CASE WHEN j.valid_at IS NULL
               THEN multirange(a.valid_at)
               ELSE multirange(a.valid_at) - j.valid_at END
        )
FROM    a
LEFT JOIN (
  SELECT  b.id, range_agg(b.valid_at) AS valid_at
  FROM    b
  GROUP BY b.id
) AS j
ON      a.id = j.id AND a.valid_at && j.valid_at
ORDER BY 1, 5
;
 id | valid_at | id | valid_at | valid_at 
----+----------+----+----------+----------
  1 | [1,20)   |    |          | [1,5)
  1 | [1,20)   |  1 | [5,10)   | [5,10)
  1 | [1,20)   |    |          | [10,15)
  1 | [1,20)   |  1 | [15,30)  | [15,20)
  2 | [1,20)   |    |          | [1,20)
  4 | [1,20)   |    |          | [1,20)
  6 | [1,20)   |    |          | [1,5)
  6 | [1,20)   |  6 | [5,10)   | [5,10)
  6 | [1,20)   |  6 | [5,12)   | [5,12)
  6 | [1,20)   |    |          | [12,20)
  7 | [5,20)   |    |          | [5,20)
  9 | [1,20)   |  9 | [1,20)   | [1,20)
(12 rows)

-- This works too, probably a better plan:
SELECT  a.*, (j2.u).*,
        COALESCE(j2.valid_at, a.valid_at) AS valid_at
FROM    a
LEFT JOIN (
  SELECT  b.id, range_agg(b.valid_at) AS valid_at, array_agg(b) AS bs
  FROM    b
  GROUP BY b.id
) AS j
ON      a.id = j.id AND a.valid_at && j.valid_at
LEFT JOIN LATERAL (
  SELECT  u, a.valid_at * u.valid_at AS valid_at
  FROM    UNNEST(j.bs) AS u
  WHERE   NOT isempty(a.valid_at * u.valid_at)
  UNION ALL
  SELECT  NULL, u.valid_at
  FROM    UNNEST(multirange(a.valid_at) - j.valid_at) AS u(valid_at)
  WHERE   NOT isempty(u.valid_at)
) AS j2
ON      true
WHERE   NOT isempty(a.valid_at)
ORDER BY a.id, COALESCE(j2.valid_at, a.valid_at);
 id | valid_at | id | valid_at | valid_at 
----+----------+----+----------+----------
  1 | [1,20)   |    |          | [1,5)
  1 | [1,20)   |  1 | [5,10)   | [5,10)
  1 | [1,20)   |    |          | [10,15)
  1 | [1,20)   |  1 | [15,30)  | [15,20)
  2 | [1,20)   |    |          | [1,20)
  4 | [1,20)   |    |          | [1,20)
  6 | [1,20)   |    |          | [1,5)
  6 | [1,20)   |  6 | [5,10)   | [5,10)
  6 | [1,20)   |  6 | [5,12)   | [5,12)
  6 | [1,20)   |    |          | [12,20)
  7 | [5,20)   |    |          | [5,20)
  9 | [1,20)   |  9 | [1,20)   | [1,20)
(12 rows)

-- A version from Boris.
-- This one also scans a twice.
SELECT  (x.a).*, (x.b).*, valid_at
FROM    (
  SELECT  a, b, a.valid_at * COALESCE(b.valid_at, a.valid_at) AS valid_at
  FROM    a
  LEFT JOIN b
  ON      a.id = b.id AND a.valid_at && b.valid_at
  WHERE   NOT isempty(a.valid_at)
  UNION ALL (
  SELECT  a, NULL, UNNEST(multirange(a.valid_at) - range_agg(b.valid_at)) AS valid_at
  FROM    a
  JOIN    b
  ON      a.id = b.id AND a.valid_at && b.valid_at
  WHERE   NOT isempty(a.valid_at)
  GROUP BY a, a.valid_at
  )
) x
ORDER BY 1, 5;
 id | valid_at | id | valid_at | valid_at 
----+----------+----+----------+----------
  1 | [1,20)   |    |          | [1,5)
  1 | [1,20)   |  1 | [5,10)   | [5,10)
  1 | [1,20)   |    |          | [10,15)
  1 | [1,20)   |  1 | [15,30)  | [15,20)
  2 | [1,20)   |    |          | [1,20)
  4 | [1,20)   |    |          | [1,20)
  6 | [1,20)   |    |          | [1,5)
  6 | [1,20)   |  6 | [5,10)   | [5,10)
  6 | [1,20)   |  6 | [5,12)   | [5,12)
  6 | [1,20)   |    |          | [12,20)
  7 | [5,20)   |    |          | [5,20)
  9 | [1,20)   |  9 | [1,20)   | [1,20)
(12 rows)

-- Another version from Boris, scanning a just once:
SELECT  (j1.a).*, (j2.b).*, j2.valid_at
FROM    (
  -- COALESCE(a.valid_at * b.valid_at, a.valid_at) is confusing.
  -- It means that if there was no match, then b is NULL for the whole duration of a.valid_at.
  SELECT  a,
          array_agg(ROW(b, COALESCE(a.valid_at * b.valid_at, a.valid_at))) AS b,
          range_agg(b.valid_at) AS valid_at
  FROM    a
  LEFT JOIN b
  ON      a.id = b.id AND a.valid_at && b.valid_at
  GROUP BY a
) AS j1
JOIN LATERAL (
  SELECT b.b, b.valid_at FROM UNNEST(j1.b) AS b(b b, valid_at int4range)
  UNION ALL
  SELECT NULL, UNNEST(multirange((j1.a).valid_at) - j1.valid_at)
) AS j2 ON true
WHERE   NOT isempty((j1.a).valid_at)
ORDER BY 1, 5;
 id | valid_at | id | valid_at | valid_at 
----+----------+----+----------+----------
  1 | [1,20)   |    |          | [1,5)
  1 | [1,20)   |  1 | [5,10)   | [5,10)
  1 | [1,20)   |    |          | [10,15)
  1 | [1,20)   |  1 | [15,30)  | [15,20)
  2 | [1,20)   |    |          | [1,20)
  4 | [1,20)   |    |          | [1,20)
  6 | [1,20)   |    |          | [1,5)
  6 | [1,20)   |  6 | [5,10)   | [5,10)
  6 | [1,20)   |  6 | [5,12)   | [5,12)
  6 | [1,20)   |    |          | [12,20)
  7 | [5,20)   |    |          | [5,20)
  9 | [1,20)   |  9 | [1,20)   | [1,20)
(12 rows)

-- The same, but with whole-row outputs:
SELECT  j1.a, j2.b, j2.valid_at
FROM    (
  SELECT  a,
          array_agg(ROW(b, COALESCE(a.valid_at * b.valid_at, a.valid_at))) AS b,
          range_agg(b.valid_at) AS valid_at
  FROM    a
  LEFT JOIN b
  ON      a.id = b.id AND a.valid_at && b.valid_at
  GROUP BY a
) AS j1
JOIN LATERAL (
  SELECT b.b, b.valid_at FROM UNNEST(j1.b) AS b(b b, valid_at int4range)
  UNION ALL
  SELECT NULL, UNNEST(multirange((j1.a).valid_at) - j1.valid_at)
) AS j2 ON true
WHERE   NOT isempty((j1.a).valid_at)
ORDER BY (j1.a).id, valid_at;
      a       |       b       | valid_at 
--------------+---------------+----------
 (1,"[1,20)") |               | [1,5)
 (1,"[1,20)") | (1,"[5,10)")  | [5,10)
 (1,"[1,20)") |               | [10,15)
 (1,"[1,20)") | (1,"[15,30)") | [15,20)
 (2,"[1,20)") |               | [1,20)
 (4,"[1,20)") |               | [1,20)
 (6,"[1,20)") |               | [1,5)
 (6,"[1,20)") | (6,"[5,10)")  | [5,10)
 (6,"[1,20)") | (6,"[5,12)")  | [5,12)
 (6,"[1,20)") |               | [12,20)
 (7,"[5,20)") |               | [5,20)
 (9,"[1,20)") | (9,"[1,20)")  | [1,20)
(12 rows)

-- Test with our function:
SELECT	*
FROM		temporal_outer_join('a', 'id', 'valid_at', 'b', 'id', 'valid_at') AS t(a a, b b, valid_at int4range)
ORDER BY (t.a).id, valid_at;
      a       |       b       | valid_at 
--------------+---------------+----------
 (1,"[1,20)") |               | [1,5)
 (1,"[1,20)") | (1,"[5,10)")  | [5,10)
 (1,"[1,20)") |               | [10,15)
 (1,"[1,20)") | (1,"[15,30)") | [15,20)
 (2,"[1,20)") |               | [1,20)
 (4,"[1,20)") |               | [1,20)
 (6,"[1,20)") |               | [1,5)
 (6,"[1,20)") | (6,"[5,10)")  | [5,10)
 (6,"[1,20)") | (6,"[5,12)")  | [5,12)
 (6,"[1,20)") |               | [12,20)
 (7,"[5,20)") |               | [5,20)
 (9,"[1,20)") | (9,"[1,20)")  | [1,20)
(12 rows)

-- Plan is good (qual pushed down, only one scan per table):
INSERT INTO a SELECT 10, int4range(i, i+1) FROM generate_series(1,1000) s(i);
CREATE INDEX idx_a_id ON a (id);
CREATE INDEX idx_b_id ON b (id);
ANALYZE a, b;
EXPLAIN SELECT	*
FROM		temporal_outer_join('a', 'id', 'valid_at', 'b', 'id', 'valid_at') AS t(a a, b b, valid_at int4range)
WHERE (t.a).id = 1
ORDER BY (t.a).id, valid_at;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Sort  (cost=15.35..15.63 rows=110 width=109)
   Sort Key: b.valid_at
   ->  Nested Loop  (cost=9.32..11.62 rows=110 width=109)
         ->  GroupAggregate  (cost=9.32..9.35 rows=1 width=105)
               Group Key: a.*
               ->  Sort  (cost=9.32..9.32 rows=1 width=108)
                     Sort Key: a.*
                     ->  Nested Loop Left Join  (cost=0.15..9.31 rows=1 width=108)
                           Join Filter: (a.valid_at && b_1.valid_at)
                           ->  Index Scan using idx_a_id on a  (cost=0.15..8.17 rows=1 width=58)
                                 Index Cond: (id = 1)
                                 Filter: (NOT isempty(valid_at))
                           ->  Seq Scan on b b_1  (cost=0.00..1.11 rows=2 width=58)
                                 Filter: (id = 1)
         ->  Append  (cost=0.00..1.18 rows=110 width=64)
               ->  Function Scan on unnest b  (cost=0.00..0.10 rows=10 width=64)
               ->  ProjectSet  (cost=0.00..0.52 rows=100 width=64)
                     ->  Result  (cost=0.00..0.01 rows=1 width=0)
(18 rows)

DROP INDEX idx_a_id;
DROP INDEX idx_b_id;
DELETE FROM a WHERE id = 10;
-- Without the support function:
CREATE OR REPLACE FUNCTION temporal_outer_join_support(INTERNAL)
RETURNS INTERNAL
AS 'temporal_ops', 'noop_support'
LANGUAGE C;
SELECT	*
FROM		temporal_outer_join('a', 'id', 'valid_at', 'b', 'id', 'valid_at') AS t(a a, b b, valid_at int4range)
ORDER BY (t.a).id, valid_at;
NOTICE:  noop_support 464
NOTICE:  noop_support 466
NOTICE:  noop_support 469
NOTICE:  noop_support 468
      a       |       b       | valid_at 
--------------+---------------+----------
 (1,"[1,20)") |               | [1,5)
 (1,"[1,20)") | (1,"[5,10)")  | [5,10)
 (1,"[1,20)") |               | [10,15)
 (1,"[1,20)") | (1,"[15,30)") | [15,20)
 (2,"[1,20)") |               | [1,20)
 (4,"[1,20)") |               | [1,20)
 (6,"[1,20)") |               | [1,5)
 (6,"[1,20)") | (6,"[5,10)")  | [5,10)
 (6,"[1,20)") | (6,"[5,12)")  | [5,12)
 (6,"[1,20)") |               | [12,20)
 (7,"[5,20)") |               | [5,20)
 (9,"[1,20)") | (9,"[1,20)")  | [1,20)
(12 rows)

